<script>
  const HEAD_PART_IDS = [0,1];

  async function setupCamera() {
    const video = document.getElementById('video');
    const stream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:'user' }, audio:false
    });
    video.srcObject = stream;
    return new Promise(res=>video.onloadedmetadata=()=>{ video.play(); res(video); });
  }

  async function main(){
    const video = await setupCamera();
    const canvas = document.getElementById('canvas');
    const ctx    = canvas.getContext('2d');
    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    const W = canvas.width, H = canvas.height;

    // offscreen canvases
    const bodyMaskCanvas = document.createElement('canvas');
    const videoCanvas    = document.createElement('canvas');
    const headMaskCanvas = document.createElement('canvas');
    const okyoCanvas     = document.createElement('canvas');
    [bodyMaskCanvas, videoCanvas, headMaskCanvas, okyoCanvas].forEach(c=>{
      c.width = W; c.height = H;
    });
    const bodyMaskCtx = bodyMaskCanvas.getContext('2d');
    const videoCtx    = videoCanvas.getContext('2d');
    const headMaskCtx = headMaskCanvas.getContext('2d');
    const okyoCtx     = okyoCanvas.getContext('2d');

    // load okyo
    const okyoImg = new Image();
    await new Promise(res=>okyoImg.onload=res);
    okyoImg.src = 'okyo.png';

    const net = await bodyPix.load({
      architecture:'MobileNetV1',
      outputStride:16,
      multiplier:0.75
    });

    async function renderFrame(){
      // 1) segment parts
      const parts = await net.segmentPersonParts(video,{
        internalResolution:'medium',
        segmentationThreshold:0.5
      });
      const data = parts.data;

      // 2) compute head centroid + height
      let sumX=0,sumY=0,count=0, minY=H, maxY=0;
      for(let i=0;i<data.length;i++){
        if(HEAD_PART_IDS.includes(data[i])){
          const x=i%W, y=(i/W)|0;
          sumX+=x; sumY+=y; count++;
          if(y<minY)minY=y;
          if(y>maxY)maxY=y;
        }
      }
      const headH = (maxY-minY+1)||1;
      const headCX = sumX/count;
      const headCY = sumY/count;

      // 3) build & blur full-body mask
      const bodyImage = bodyMaskCtx.createImageData(W,H);
      for(let i=0;i<data.length;i++){
        bodyImage.data[4*i+3] = data[i]>=0?255:0;
      }
      bodyMaskCtx.clearRect(0,0,W,H);
      bodyMaskCtx.putImageData(bodyImage,0,0);
      bodyMaskCtx.filter = 'blur(20px)';
      bodyMaskCtx.drawImage(bodyMaskCanvas,0,0);
      bodyMaskCtx.filter = 'none';

      // 4) mask out only the body
      videoCtx.clearRect(0,0,W,H);
      videoCtx.drawImage(video,0,0,W,H);
      videoCtx.globalCompositeOperation = 'destination-in';
      videoCtx.drawImage(bodyMaskCanvas,0,0);
      videoCtx.globalCompositeOperation = 'source-over';

      // 5) build & blur head-only mask
      const headImage = headMaskCtx.createImageData(W,H);
      for(let i=0;i<data.length;i++){
        if(HEAD_PART_IDS.includes(data[i])){
          headImage.data[4*i+3] = 255;
        }
      }
      headMaskCtx.clearRect(0,0,W,H);
      headMaskCtx.putImageData(headImage,0,0);
      headMaskCtx.filter = 'blur(10px)';
      headMaskCtx.drawImage(headMaskCanvas,0,0);
      headMaskCtx.filter = 'none';

      // 6) draw+clip okyo to head mask
      okyoCtx.clearRect(0,0,W,H);
      const scale = 600/headH;
      const w = okyoImg.width/scale, h = okyoImg.height/scale;
      okyoCtx.drawImage(okyoImg, headCX-w/2, headCY-h/2, w, h);
      okyoCtx.globalCompositeOperation = 'destination-in';
      okyoCtx.drawImage(headMaskCanvas,0,0);
      okyoCtx.globalCompositeOperation = 'source-over';

      // 7) final composite
      ctx.clearRect(0,0,W,H);
      // a) only the clipped okyo
      ctx.drawImage(okyoCanvas,0,0);
      // b) the body beneath
      ctx.drawImage(videoCanvas,0,0,W,H);

      requestAnimationFrame(renderFrame);
    }

    renderFrame();
  }

  main().catch(console.error);
</script>
